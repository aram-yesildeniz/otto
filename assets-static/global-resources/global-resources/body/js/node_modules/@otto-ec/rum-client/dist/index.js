window.AS = window.AS || {};

window.AS.config = window.AS.config || {
  localStoragePrefix: "o_",
  requestDataFormat: "kv", // Actual format could be either "kv" or "json".
  loadQueueDelay: 200,
  asyncQueueInterval: 400,
  asyncQueueTimeout: 4000,
  beaconBaseUrl: "/error-logging/",
  beacons: {
    performance: "ottoperformance.gif",
    javascript: "ottojs.gif",
    custom: "ottocustom.gif"
  },
  comScoreUrl: ""
};


window.AS = window.AS || {};

window.o_scale = window.o_scale || {};

/**
 * Client side (performance) monitoring. Takes values from:
 * performance.timing, printing events, attempts to XSS your
 * site by wrapping and logging console.log() and alert(),
 * JavaScript Errors occuring on the client side and
 * transmitts them to the specified URL so they are accessible
 * in the logfiles.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} config   Configuration object (window.AS.config)
 */
window.AS.RUM = (function(w, d, config) {
  "use strict";

  const dataContainer = {};
  const taskQueue = [];
  const mousemoveStartTimestamp = 0;
  const EMERGENCY_RUM_TOGGLE = "EMR_RUM";

  const storage = new o_global.Storage(function() {
    return window.localStorage;
  });

  /**
   * Compare function to sort an array of objects based on given object property.
   * If the property has a preceding minus sign, the sort order is descending.
   *
   * @param {string} property     Key on which the array of objects will be sorted.
   *
   * @return {Function} Return a sort function.
   */
  function sortArrayOfObjects(property) {
    let sortOrder = 1;
    let key = property;

    if (key[0] === "-") {
      sortOrder = -1;
      key = key.substr(1);
    }

    return function(a, b) {
      const result = a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0;

      return result * sortOrder;
    };
  }

  /**
   * Detect wether localStorage is available or not.
   *
   * @return {boolean} Is localStorage really available?
   */
  function isLocalStorageAvailable() {
    return !!storage.isAvailable;
  }

  /**
   * Detect wether the Navigation Timing API is available.
   *
   * @param {string} feature  Performance API feature that will be detected, could be "memory", "navigation", "timing" or "getEntries".
   *
   * @return {boolean} Is window.performance API available?
   */
  function isPerformanceFeatureAvailable(feature) {
    const perf =
      w.performance ||
      w.mozPerformance ||
      w.webkitPerformance ||
      w.msPerformance;
    let result;

    if (perf) {
      result = window.performance[feature];
    }

    return !!result;
  }

  /**
   * Returns true if all immediate properties of an object
   * are true, false otherwise.
   *
   * @param {string} obj      Object to check for truthy properties.
   *
   * @return {boolean} Are all properties true?
   */
  function allPropsTrue(obj) {
    let i;

    for (i in obj) {
      if (obj.hasOwnProperty(i) && !obj[i]) {
        return false;
      }
    }

    return true;
  }

  /**
   * Extends a given namespace, usually "window", with the namespaceString,
   * that will evaluate to a RUM task, that could be called afterwards.
   * Needed to call methods that were registered in the task queue.
   *
   * @param {string|Object} namespace     Parent namespace that will be extended, e.G. "window".
   * @param {string} namespaceString      Extension string, e.G. "window.AS.RUM".
   *
   * @return {string|false} parent
   */
  function extendNamespace(namespace, namespaceString) {
    let parts = namespaceString ? namespaceString.split(".") : [];
    let parent = namespace || "";
    let pl;
    let i;

    if (!!namespace && !!namespaceString) {
      /* istanbul ignore else */
      if (parts[0] === "window") {
        parts = parts.slice(1);
      }

      pl = parts.length;

      for (i = 0; i < pl; i += 1) {
        /* istanbul ignore else */
        if (typeof parent[parts[i]] === "undefined") {
          parent[parts[i]] = {};
        }

        parent = parent[parts[i]];
      }

      return parent;
    }

    return false;
  }

  /**
   * Sends an image beacon request with all dataContainer information as parameters.
   *
   * @param {string} timing       Timing string, e.G. "ready", "load".
   * @param {string} group        Group name, e.G. "performance", "print", etc.
   * @param {Object} params       Payload object.
   * @param {boolean} ongoing     Determines if beacon will be send continously.
   *
   * @return {boolean} Returns true if beacon was send successfully, false otherwise.
   */
  function sendImageBeacon(timing, group, params, ongoing) {
    const sendPermanently = typeof ongoing === "boolean" ? ongoing : false;
    let dataContainerRef;
    let beaconUrl;
    let beacon;

    // Will not be sent when the global rum toggle is deactivated
    if (
      !o_util.toggle.get(EMERGENCY_RUM_TOGGLE, true) ||
      o_util.misc.isPreview(w.location.href)
    ) {
      return false;
    }

    if (
      window.location.hostname.indexOf("localhost") === -1 &&
      window.location.hostname.indexOf("otto.de") === -1
    ) {
      // Will not be sent, if page is not www.otto.de. If it is not otto.de sent only security-Beacon (localhost needed for testing)
      return false;
    }

    if (
      !!timing &&
      !!group &&
      !!config.beacons[group] &&
      typeof params === "object"
    ) {
      if (!dataContainer[timing]) {
        dataContainer[timing] = {};
      }

      if (!dataContainer[timing][group]) {
        dataContainer[timing][group] = {};
      }

      dataContainerRef = dataContainer[timing][group];
      if (!dataContainerRef.send) {
        dataContainerRef.send = false;
      }

      beacon = d.createElement("img");
      /* istanbul ignore next */
      beacon.onload = function() {
        dataContainerRef.send = !sendPermanently;
      };
      /* istanbul ignore next */
      beacon.onerror = function() {
        // eslint-disable-line
      };

      if (dataContainerRef.send !== true && Object.keys(params).length > 0) {
        if (
          group === "performance" &&
          window.o_scale.rum &&
          typeof window.o_scale.rum.sendData === "function"
        ) {
          window.o_scale.rum.sendData(params);
        } else {
          beaconUrl = config.beaconBaseUrl + config.beacons[group];

          switch (config.requestDataFormat) {
            case "kv":
              if (group === "javascript" || group === "custom") {
                // o_util.core.serialize replaces `%20` with `+` in the end.
                // We don`t want that for error or custom logging.
                beacon.src = `${beaconUrl}?${o_util.core
                  .serialize(params)
                  .replace(/\+/g, "%20")}`;
              } else {
                beacon.src = `${beaconUrl}?${o_util.core.serialize(params)}`;
              }
              break;
            case "json":
              beacon.src = `${beaconUrl}?data=${encodeURIComponent(
                JSON.stringify(params)
              )}`;
              break;
            default:
              break;
          }
        }

        return true;
      }
      dataContainerRef.send = true;

      return false;
    }

    return false;
  }

  /**
   * Adds a RUM task to the taskQueue specifying a timing parameter and
   * a process order based on a number.
   *
   * @param {string} beacon       Beacon identifier for the beacon the measuring data will be send to.
   * @param {string} timing       Determines when the task will be executed, i.E. OnLoad, domReady.
   * @param {string} task         The RUM task to execute.
   * @param {number} priority     Set the order of execution in timing block.
   * @param {boolean} async       Determines if a task has to be executed asynchronously.
   *
   * @return {boolean} Was the function added to the task queue successfully?
   */
  function addToTaskQueue(beacon, timing, task, priority, async) {
    const type = async || false;
    const order = priority || 0;

    if (!!beacon && !!config.beacons[beacon] && !!timing && !!task) {
      taskQueue.push({
        beacon,
        timing,
        task,
        order,
        async: type
      });

      return true;
    }

    return false;
  }

  /**
   * Remove a specific task from the taskQueue.
   *
   * @param {string} beacon   Beacon identifier.
   * @param {string} timing   Timing string.
   * @param {string} task     Task name.
   *
   * @return {boolean} Was the removal successful?
   */
  function removeFromTaskQueue(beacon, timing, task) {
    let ret;

    if (!!beacon && !!timing && !!task) {
      taskQueue.forEach(function(el, i) {
        if (el.beacon === beacon && el.timing === timing && el.task === task) {
          taskQueue.splice(i, 1);
          ret = true;
        } else {
          ret = false;
        }
      });
    } else {
      ret = false;
    }

    return ret;
  }

  /**
   * Returns an object containing all registered RUM tasks that should be sent
   * by one specific beacon ordered by priority.
   * If a timing parameter is given, the returned object only contains tasks,
   * that where registered to be executed in that timing.
   * Possible timing values are "load" and "ready".
   *
   * @param {string} beacon   Beacon identifier.
   * @param {string} timing   Which timing should be used.
   *
   * @return {Object} Tasklist object.
   */
  function getTaskQueue(beacon, timing) {
    const taskList = [];
    let item;

    taskQueue.sort(sortArrayOfObjects("order"));

    /* istanbul ignore else */
    if (!!beacon && beacon in config.beacons && !!timing) {
      for (item in taskQueue) {
        /* istanbul ignore else */
        if (taskQueue.hasOwnProperty(item)) {
          if (
            taskQueue[item].timing === timing &&
            taskQueue[item].beacon === beacon
          ) {
            taskList.push({
              task: taskQueue[item].task,
              async: taskQueue[item].async
            });
          }
        }
      }
    }

    return taskList;
  }

  /**
   * Resets all tasks that were queued earlier.
   * @returns {undefined}
   */
  function clearTaskQueue() {
    taskQueue.length = 0;
  }

  /**
   * Detect if a all async methods of each beacon group are finished and
   * the beacon group is ready to send the appropriate image beacon.
   *
   * @return {Number|Object} Return given result or send counter.
   */
  function checkAsyncTasks() {
    const result = [];
    let counter = 0;
    let timing;
    let beacon;

    for (timing in dataContainer) {
      if (dataContainer.hasOwnProperty(timing)) {
        for (beacon in dataContainer[timing]) {
          if (dataContainer[timing].hasOwnProperty(beacon)) {
            if (dataContainer[timing][beacon].async) {
              if (
                !!allPropsTrue(dataContainer[timing][beacon].asyncTasks) &&
                dataContainer[timing][beacon].send === false
              ) {
                dataContainer[timing][beacon].done = true;
                result.push({
                  timing,
                  beacon,
                  params: dataContainer[timing][beacon].data,
                  send: dataContainer[timing][beacon].send
                });
              } else {
                counter += 1;
              }
            }
          }
        }
      }
    }

    return result.length > 0 ? result : counter;
  }

  /**
   * Responsible for handling all beacon request based on a given timing and beacon type.
   *
   * @param {string} timing   What timing will be handled?.
   * @param {string} beacon   Which beacon will be used?.
   *
   * @returns {undefined}
   */
  function handleBeaconRequest(timing, beacon) {
    if (!!timing && !!beacon) {
      try {
        sendImageBeacon(
          timing,
          beacon,
          dataContainer[timing][beacon].data,
          false
        );
      } catch (e) {
        // TODO: Implement catch functionality.
      }
    }
  }

  /**
   * Generating dedicated space for all relevant beacon data
   * for any given measurement typ and beacon.
   *
   * @param {string} type     Measurement type.
   * @param {string} beacon   Beacon identifier.
   *
   * @returns {undefined}
   */
  function prepareDataContainer(type, beacon) {
    if (typeof dataContainer[type] === "undefined") {
      dataContainer[type] = {};
    }

    dataContainer[type][beacon] = {};
    dataContainer[type][beacon].data = {};
    dataContainer[type][beacon].asyncTasks = {};
    dataContainer[type][beacon].async = false;
    dataContainer[type][beacon].done = false;
    dataContainer[type][beacon].send = false;
  }

  /**
   * Working through all registered tasks.
   *
   * @param {string} timing       Timing string.
   * @param {boolean} doRequest   Should the imagebeacon be send directly?.
   * @param {Array} parameter     Further parameters.
   *
   * @returns {undefined}
   */
  function handleTasks(timing, doRequest, parameter) {
    const params = parameter || [];
    const req = doRequest || true;
    let beacon;
    let data;
    let target;
    let tasks;

    if (timing) {
      for (beacon in config.beacons) {
        if (config.beacons.hasOwnProperty(beacon)) {
          tasks = getTaskQueue(beacon, timing);
          if (tasks.length > 0) {
            prepareDataContainer(timing, beacon);

            // because of for ... loop
            // eslint-disable-next-line
            tasks.forEach((el) => {
              if (el.async) {
                dataContainer[timing][beacon].async = true;
                dataContainer[timing][beacon].asyncTasks[el.task] = false;
                params.unshift(el.task, dataContainer[timing][beacon]);

                // prefer-spread: Verstehe ich nicht!
                // eslint-disable-next-line
                extendNamespace(window, el.task).apply(null, params);
              } else {
                // prefer-spread: Verstehe ich nicht!
                // eslint-disable-next-line
                data = extendNamespace(window, el.task).apply(null, params);
                target = dataContainer[timing][beacon].data;
                o_util.core.extend(target, data, false, false);
              }
            });

            if (!!req && dataContainer[timing][beacon].async !== true) {
              handleBeaconRequest(timing, beacon);
            }
          }
        }
      }
    }
  }

  /**
   * Who moves this function into rum_page module and fails, increase this counter: 1.
   *
   * Reads the pagecluster information from html-data-attribute.
   * In common it returns the pagecluster information.
   * If data-pagecluster is not set, it returns the initial value or if
   * this attribute exists but the value is empty it returns the error value.
   *
   * @return {Object} Return RUM extended with pageCluster.
   */
  function getPagecluster() {
    const data = {
      pagecluster: -2
    };
    const dataPageCluster = o_util.misc.getPagecluster();

    if (dataPageCluster) {
      data.pagecluster = dataPageCluster;
    } else if (dataPageCluster === "") {
      data.pagecluster = -1;
    }

    return data;
  }

  /**
   * Runs all queued RUM tasks doing all the fancy stuff.
   *
   * @returns {undefined}
   */
  function cheers() {
    //  Document ready
    o_global.eventLoader.onReady(0, function() {
      handleTasks("ready", true, []);
    });

    //  Window onload handler registered via the global onloadHandler
    o_global.eventLoader.onLoad(0, function() {
      o_global.eventLoader.onAllScriptsExecuted(0, function() {
        setTimeout(function() {
          handleTasks("load", true, []);
        }, config.loadQueueDelay);

        const timer = setInterval(function() {
          const check = checkAsyncTasks();
          let i;

          if (check) {
            for (i in check) {
              if (check.hasOwnProperty(i) && check[i].send !== true) {
                handleBeaconRequest(check[i].timing, check[i].beacon);
              }
            }
          } else {
            clearInterval(timer);
          }
        }, config.asyncQueueInterval);

        setTimeout(function() {
          clearInterval(timer);
        }, config.asyncQueueTimeout);
      });
    });

    //  Window onerror
    w.addEventListener("error", function(event) {
      handleTasks("error", true, [
        event.message,
        event.filename,
        event.lineno,
        event.colno,
        event.error
      ]);
    });

    // Catch unhandled rejection errors (works currently only in Chrome and Edge; 10.04.19)
    w.addEventListener("unhandledrejection", function(event) {
      handleTasks("error", true, [
        event.reason && event.reason.message
          ? event.reason.message
          : "No reason given (empty promise rejection).",
        undefined,
        undefined,
        undefined,
        event.reason
      ]);
    });
  }

  // Setting availability properties.
  const localStorageAvailable = isLocalStorageAvailable();
  const navigationTimingAvailable = isPerformanceFeatureAvailable("timing");
  const resourceTimingAvailable = isPerformanceFeatureAvailable("getEntries");

  return {

    storage,
    taskQueue,
    dataContainer,
    localStorageAvailable,
    navigationTimingAvailable,
    resourceTimingAvailable,
    sendImageBeacon,
    getPagecluster,
    addToTaskQueue,
    cheers
  };
})(window, document, window.AS.config);

// Let the magic begin...
window.AS.RUM.cheers();


/**
 * RUM extension for measuring cross-browser latency.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM object.
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  const timing = RUM.navigationTimingAvailable ? w.performance.timing : false;
  const perf = w.performance;
  const xhr = w.XMLHttpRequest;
  const storage = new o_global.Storage(function() {
    return window.localStorage;
  });

  // TODO: Remove rum_ labels when generic solution for comScore is in use.
  const perfDataDetailed = [
    {
      name: "networkTime",
      minuend: "responseEnd",
      subtrahend: "navigationStart"
    },
    {
      name: "domContentLoadedStart",
      minuend: "domContentLoadedEventStart",
      subtrahend: "navigationStart"
    },
    {
      name: "domContentLoaded",
      minuend: "domContentLoadedEventEnd",
      subtrahend: "navigationStart"
    },
    {
      name: "domTime",
      minuend: "domComplete",
      subtrahend: "domLoading"
    },
    {
      name: "dnsTime",
      minuend: "domainLookupEnd",
      subtrahend: "domainLookupStart"
    }
  ];

  const perfDataImportant = [
    {
      name: "timeToFirstByte",
      minuend: "responseStart",
      subtrahend: "navigationStart"
    },
    {
      name: "rum_complete",
      minuend: "loadEventEnd",
      subtrahend: "navigationStart"
    },
    {
      name: "rum_domComplete",
      minuend: "domComplete",
      subtrahend: "navigationStart"
    },
    {
      name: "sslHandshakeTime",
      minuend: "connectEnd",
      subtrahend: "secureConnectionStart"
    }
  ];

  const staticBrowserDataDetailed = [
    {
      name: "htmlLength",
      value: d.body.innerHTML.length
    }
  ];

  const staticBrowserDataBasic = [
    {
      name: "parentUrl",
      value: w.location.href
    },
    {
      name: "referrer", // LHAS-1917: Limit length of the referrer to 256 chars.
      value: d.referrer.substring(0, 256)
    }
  ];

  function _addPerfData(config) {
    const data = {};

    config.forEach(function(el) {
      const min = el.minuend;
      const sub = el.subtrahend;
      let val;

      data[el.name] = -2;

      if (timing) {
        val =
          !!timing[min] && !!timing[sub] && timing[min] - timing[sub] >= 0
            ? timing[min] - timing[sub]
            : -1;
        data[el.name] = val;
      }
    });

    return data;
  }

  function _getStaticBrowserData(staticBrowserData) {
    const data = {};

    staticBrowserData.forEach(function(el) {
      data[el.name] = el.value ? el.value : -1;
    });

    return data;
  }

  /**
   * Calculates all relevant performance data based on perfData config array.
   * Properties of navigation timing api must be defined and the results of
   * subtractions need to be bigger than zero.
   * Otherwise dataContainerValue will be -1 to be filtered in reports.
   * If navigation timing api is not available all values will remain -2.
   *
   * @return {Object} Measured performance data.
   */
  function getPerfData() {
    return _addPerfData(perfDataDetailed.concat(perfDataImportant));
  }

  /**
   * Calculates all relevant performance data based on perfDataDetailed config array.
   * Properties of navigation timing api must be defined and the results of
   * subtractions need to be bigger than zero.
   * Otherwise dataContainerValue will be -1 to be filtered in reports.
   * If navigation timing api is not available all values will remain -2.
   *
   * @return {Object} Measured performance data.
   */
  function getPerfDataDetailed() {
    return _addPerfData(perfDataDetailed);
  }

  /**
   * Calculates all relevant performance data based on perfDataDetailed config array.
   * Properties of navigation timing api must be defined and the results of
   * subtractions need to be bigger than zero.
   * Otherwise dataContainerValue will be -1 to be filtered in reports.
   * If navigation timing api is not available all values will remain -2.
   *
   * @return {Object} Measured performance data.
   */
  function getPerfDataImportant() {
    return _addPerfData(perfDataImportant);
  }

  /**
   * Aggregates static browser values like location href or document referrer.
   * Further browser data has to be added in staticBrowserData array above.
   *
   * @return {Object} Payload data object that contains static browser data.
   */
  function getStaticBrowserData() {
    return _getStaticBrowserData(
      staticBrowserDataBasic.concat(staticBrowserDataDetailed)
    );
  }

  /**
   * Aggregates static browser values like location href or document referrer.
   * Further browser data has to be added in staticBrowserData array above.
   *
   * @return {Object} Payload data object that contains static browser data.
   */
  function getStaticBrowserDataBasic() {
    return _getStaticBrowserData(staticBrowserDataBasic);
  }

  /**
   * Aggregates static browser values like htmlLength.
   * Further browser data has to be added in staticBrowserData array above.
   *
   * @return {Object} Payload data object that contains static browser data.
   */
  function getStaticBrowserDataDetailed() {
    return _getStaticBrowserData(staticBrowserDataDetailed);
  }

  /**
   * Retrieve unique browser- and visitorId.
   *
   * @return {Object} Payload data containing vid and bid.
   */
  function getUniqueIds() {
    const data = {
      vid: -2,
      bid: -2
    };

    data.vid = o_util.cookie.get("visitorId")
      ? o_util.cookie.get("visitorId")
      : -1;
    data.bid = o_util.cookie.get("BrowserId")
      ? o_util.cookie.get("BrowserId")
      : -1;

    return data;
  }

  /**
   * Detect whether the referrer of the current document is part of the same domain or not.
   *
   * @return {Object} Did we got a first view?
   */
  function isFirstView() {
    const ref = document.referrer;
    const data = {
      firstView: -2
    };

    data.firstView = !(!!ref && ref.indexOf("www.otto.de") > -1);

    return data;
  }

  /**
   * Determine if the page was delivered for a browser or an app.
   * Currently based on cookie value.
   *
   * @return {Object} Was the page loaded in a webview?
   */
  function isApp() {
    return {
      app: o_global.helper.cookieExist("app")
    };
  }

  /**
   * Determine the current breakpoint.
   *
   * @return {Object} Data object that holds current breakpoint.
   * @todo check if used by others
   */
  function getBreakpoint() {
    const data = {
      bp: -2
    };

    if (
      !!o_global &&
      !!o_global.device &&
      !!o_global.device.breakpoint &&
      typeof o_global.device.breakpoint.getCurrentBreakpoint === "function"
    ) {
      data.bp = o_global.device.breakpoint.getCurrentBreakpoint();
    }

    return data;
  }

  /**
   * Hijack all native ajax calls. Override xhr.open function.
   *
   * @private
   * @returns {undefined}
   */
  function _initNativeProxy() {
    // Override and pass the initial function
    xhr.prototype.open = _openProxy(xhr.prototype.open);
  }

  /**
   * Proxy all window.XMLHttpRequest.open calls.
   *
   * @private
   *
   * @param {Function} initialFunction   Initial open function.
   *
   * @return {Function}                  Initial open function.
   */
  function _openProxy(initialFunction) {
    return function(type, url) {
      // Track only tracking requests
      if (url.indexOf("/ts-rcv/") !== -1) {
        // Hijack send function
        this.send = _sendProxy(this.send, url);
      }

      // Call initial open function
      return initialFunction
        ? initialFunction.apply(this, [].slice.call(arguments))
        : null;
    };
  }

  /**
   * Proxy all window.XMLHttpRequest.send calls.
   *
   * @private
   *
   * @param {Function} initialFunction   Initial open function.
   * @param {string} url   Called URL (For IE -.-).
   *
   * @return {Function}  Initial open function.
   */
  function _sendProxy(initialFunction, url) {
    return function() {
      // Hijack onreadystatechange function
      this.onreadystatechange = _onReadyStateChangeProxy(
        this,
        url,
        this.onreadystatechange
      );

      // Call initial open function
      return initialFunction
        ? initialFunction.apply(this, [].slice.call(arguments))
        : null;
    };
  }

  /**
   * Proxy all ready state change events.
   *
   * @private
   *
   * @param {XMLHttpRequest} currentXhr   Current XHR.
   * @param {string} url                  Called URL (For IE -.-).
   * @param {Function} initialFunction    Initial onreadystatechange function.
   * @return {Function}                   Initial onreadystatechange function.
   */
  function _onReadyStateChangeProxy(currentXhr, url, initialFunction) {
    return function() {
      // If it's done...
      if (currentXhr.readyState === 4) {
        // Do not disturb ajax call and run async
        setTimeout(function() {
          // Analyse it
          _analyseRequest(url);
        }, 1);
      }

      // Call initial onreadystatechange function
      return initialFunction
        ? initialFunction.apply(this, [].slice.call(arguments))
        : null;
    };
  }

  /**
   * Analyse the current request.
   *
   * @private
   *
   * @param {string} url  Called URL (For IE -.-).
   * @returns {false | undefined} returns false if request is not a tracking request
   */
  function _analyseRequest(url) {
    let entries;
    let entry;

    // Track only tracking requests
    if (url.indexOf("/ts-rcv/") === -1) {
      return false;
    }

    // Try to find it with absolute path (for 99% requests...)
    entries = perf.getEntriesByName(
      `${document.location.protocol}//${document.location.host}${url}`
    );

    // If not found
    if (!entries.length) {
      // Try to find it with relative path
      entries = perf.getEntriesByName(url);
    }

    // If found
    if (entries.length) {
      // Get last entry if more than one found (SHOULD be the same one...)
      entry = entries.pop();

      // Store values
      _storeRequestMetrics(entry);
    }

    return undefined;
  }

  /**
   * Store metrics for the performance entry.
   *
   * @private
   *
   * @param {number} entry  Performance entry.
   * @returns {undefined}
   */
  function _storeRequestMetrics(entry) {
    const rtt = Math.min(entry.duration, 10000); // Max 10 sec.
    const negativeRttErrorCode = -1;

    if (rtt < 0) {
      storage.setItem("rum_srttErrorCode", negativeRttErrorCode);
    } else {
      _storeRttValues(Math.round(entry.duration)); // Store the correct value in RttValues
      _storeRttCount();
      _storeSrtt(rtt);
      _storeRttVar(rtt);
    }
  }

  /**
   * Store last 20 round trip time values seperated by pipe.
   *
   * @private
   *
   * @param {number} rtt  RTT-Value.
   * @returns {undefined}
   */
  function _storeRttValues(rtt) {
    let rum_rttValues = storage.getItem("rum_rttValues"); // Get current

    // Split string or create new array
    rum_rttValues = rum_rttValues ? rum_rttValues.split("|") : [];

    // Push current rtt
    rum_rttValues.push(Math.round(rtt));

    // Store it to localStorage
    storage.setItem("rum_rttValues", rum_rttValues.slice(-20).join("|"));
  }

  /**
   * Store the count of calculated rtts.
   *
   * @private
   * @returns {undefined}
   */
  function _storeRttCount() {
    let rum_rttCount = storage.getItem("rum_rttCount"); // Get current count

    // Parse string or start at 0
    rum_rttCount = rum_rttCount ? parseInt(rum_rttCount, 10) : 0;

    // Increment the count and store it to localStorage
    storage.setItem("rum_rttCount", (rum_rttCount + 1).toString());
  }

  /**
   * Calculate smoothed round trip time.
   * SRTT = SRTT + 0.125 * (RTT – SRTT).
   *
   * @private
   *
   * @param {number} rtt      Current round trip time.
   * @param {number} srtt     Last smoothed round trip time.
   *
   * @return {number} Calculated smoothed round trip time.
   */
  function _computeSrtt(rtt, srtt) {
    return !srtt ? rtt : srtt + 0.125 * (rtt - srtt);
  }

  /**
   * Store round trip time to localstorage.
   *
   * @private
   *
   * @param {number} rtt  Current round trip time.
   * @returns {undefined}
   */
  function _storeSrtt(rtt) {
    storage.setItem(
      "rum_srtt",
      _computeSrtt(rtt, parseFloat(storage.getItem("rum_srtt"))).toString()
    );
  }

  /**
   * Calculate round trip time variance.
   * RTTVAR + 0.25 * (|SRTT – RTT| - RTTVAR).
   *
   * @private
   *
   * @param {number} rtt          Current round trip time.
   * @param {number} lastRttVar   Last round trip time.
   * @param {number} srtt         Current smoothed round trip time.
   *
   * @return {number}             Round trip time variance.
   */
  function _computeRttVar(rtt, lastRttVar, srtt) {
    return !lastRttVar
      ? rtt * 0.5
      : lastRttVar + 0.25 * (Math.abs(srtt - rtt) - lastRttVar);
  }

  /**
   * Store round trip time variance to localStorage.
   *
   * @private
   *
   * @param {number}  rtt         Current round trip time.
   * @returns {undefined}
   */
  function _storeRttVar(rtt) {
    const currentRttVar = parseFloat(storage.getItem("rum_rttVar"));
    const srtt = parseFloat(storage.getItem("rum_srtt"));

    storage.setItem(
      "rum_rttVar",
      _computeRttVar(rtt, currentRttVar, srtt).toString()
    );
  }

  /**
   * Track ajax performance and store metrics into local storage.
   * Currently only tracking call are being analyzed. Not supported in IE<10.
   *
   * @returns {false|undefined} return false if not supported
   */
  function trackAjaxPerformance() {
    if (
      !xhr ||
      !perf ||
      typeof perf.getEntriesByName !== "function" ||
      !storage.isAvailable
    ) {
      return false;
    }

    // Init proxies
    return _initNativeProxy();
  }

  /**
   * @return {{resourceCount: number}} objct with resource count
   */
  function trackResourceCount() {
    const data = {
      resourceCount: -2
    };

    if (perf && typeof perf.getEntriesByType === "function") {
      data.resourceCount = perf
        .getEntriesByType("resource")
        .filter(function(r) {
          return (
            ["link", "script"].indexOf(r.initiatorType) !== -1 &&
            r.name.indexOf("otto.de/") !== -1
          );
        }).length;
    }

    return data;
  }

  /**
   * @returns {{timeToFirstPaint: number}} object with timeToFirstPaint time
   */
  function trackTimeToFirstPaint() {
    const data = {
      timeToFirstPaint: -2
    };
    let firstPaintTime;

    if ("chrome" in w && typeof w.chrome.loadTimes === "function") {
      // loadTimes()  is specific to Chrome.
      const loadTimes = w.chrome.loadTimes();

      if (loadTimes.firstPaintTime > 0) {
        firstPaintTime = loadTimes.firstPaintTime - loadTimes.startLoadTime;
      }

      // A small percentage of traffic from Chrome in the wild returns impossibly large values – 2+
      // days! – which need to be filtered out:
      if (firstPaintTime > 0 && firstPaintTime < 3600) {
        data.timeToFirstPaint = Math.round(firstPaintTime * 1000);
      }
    } else if (timing) {
      if (timing.navigationStart !== 0) {
        // timing.msFirstPaint is specific to Internet Explorer.
        if (typeof timing.msFirstPaint === "number") {
          firstPaintTime = timing.msFirstPaint - timing.navigationStart;
        }

        if (typeof firstPaintTime === "number" && firstPaintTime > 0) {
          data.timeToFirstPaint = firstPaintTime;
        }
      }
    }

    return data;
  }

  /**
   * @return {{inlineScripts: number}} object with inlineScripts count
   */
  function trackInlineScripts() {
    return {
      inlineScripts: document.querySelectorAll(
        "body script[type='text/javascript']:not([src]), body script:not([type]):not([src])"
      ).length
    };
  }

  /**
   * @return {{supportsPreload: boolean}} object with supportsPreload indication
   */
  function supportsLinkPreload() {
    const link = document.createElement("link");

    return {
      supportsLinkPreload:
        !!link.relList &&
        !!link.relList.supports &&
        link.relList.supports("preload")
    };
  }

  /**
   * Collect data from localStorage stored by trackAjaxPerformance() and return it to rum.
   *
   * @return {Object}  Data Object
   */
  function collectAjaxPerformance() {
    const entryErrorCode = -3;
    const notAvailableErrorCode = -2;
    const data = {
      rum_srtt: entryErrorCode,
      rum_rttVar: entryErrorCode,
      rum_rttCount: entryErrorCode,
      rum_rttValues: entryErrorCode
    };
    let rum_srtt;
    let rum_rttVar;
    let rum_rttCount;
    let rum_rttValues;
    let rum_srttErrorCode;

    if (storage.isAvailable) {
      // Get stored data
      rum_srtt = storage.getItem("rum_srtt");
      rum_rttVar = storage.getItem("rum_rttVar");
      rum_rttCount = storage.getItem("rum_rttCount");
      rum_rttValues = storage.getItem("rum_rttValues");

      if (!rum_srtt) {
        rum_srttErrorCode = storage.getItem("rum_srttErrorCode");
        data.rum_srttErrorCode = rum_srttErrorCode || entryErrorCode;

        // Clear storage
        storage.removeItem("rum_srttErrorCode");
      } else {
        // Check if values are stored
        data.rum_srtt = rum_srtt;
        data.rum_rttVar = Math.round(rum_rttVar);
        data.rum_rttCount = rum_rttCount;
        data.rum_rttValues = rum_rttValues;

        // Clear rum_rttCount and rum_rttValues
        storage.removeItem("rum_rttCount");
        storage.removeItem("rum_rttValues");
      }
    }

    if (
      !storage.isAvailable ||
      !RUM.navigationTimingAvailable ||
      !RUM.resourceTimingAvailable
    ) {
      data.rum_srttErrorCode = notAvailableErrorCode;
    }

    return data;
  }

  // Add the performance measurements to the RUM task queue.

  function _init() {
    if (o_util.toggle.get("RUM_BasicInformation", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getStaticBrowserDataBasic",
        0,
        false
      );
      RUM.addToTaskQueue("performance", "load", "AS.RUM.isApp", 0, false);
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getUniqueIds",
        0,
        false
      );
    }

    if (o_util.toggle.get("RUM_DetailedPerformance", false)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getStaticBrowserDataDetailed",
        0,
        false
      );
      RUM.addToTaskQueue("performance", "load", "AS.RUM.isFirstView", 0, false);
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getPerfDataDetailed",
        0,
        false
      );
    }

    if (o_util.toggle.get("RUM_ImportantPerformance", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getPerfDataImportant",
        0,
        false
      );
    }

    if (o_util.toggle.get("RUM_RoundTripTime", true)) {
      RUM.addToTaskQueue(
        "performance",
        "ready",
        "AS.RUM.trackAjaxPerformance",
        0,
        false
      );
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.collectAjaxPerformance",
        0,
        false
      );
    }

    if (o_util.toggle.get("RUM_AssetX", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.trackResourceCount",
        0,
        false
      );
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.trackTimeToFirstPaint",
        0,
        false
      );
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.trackInlineScripts",
        0,
        false
      );
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.supportsLinkPreload",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {

      getPerfData,
      getPerfDataImportant,
      getPerfDataDetailed,
      getStaticBrowserData,
      getStaticBrowserDataDetailed,
      getStaticBrowserDataBasic,
      getUniqueIds,
      isFirstView,
      isApp,
      getBreakpoint,
      trackAjaxPerformance,
      collectAjaxPerformance,
      trackResourceCount,
      trackTimeToFirstPaint,
      trackInlineScripts,
      supportsLinkPreload
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/**
 * RUM extension page visibility API.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM object.
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  /**
   * Retrieve several information about page visibility.
   *
   * @return {Object} Page visibility information.
   */
  function checkVisibilityData() {
    const visibilityData = o_global.visibilityChange.getVisibilityData();
    const data = {
      rum_wasHidden: -2,
      rum_pageVisibility: -2,
      rum_visibilityChanges: -2,
      rum_hiddenTime: -2,
      rum_visibleLoadTime: -2,
      rum_customerWaitTime: -2
    };
    let key;

    // Same structure in data and visibilityData for non "rum_" keys.
    for (key in visibilityData) {
      if (visibilityData.hasOwnProperty(key)) {
        data[`rum_${key}`] = visibilityData[key];
      }
    }

    return data;
  }

  // Add the visibility measurements to the RUM task queue.
  function _init() {
    if (o_util.toggle.get("RUM_Visibility", false)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.checkVisibilityData",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {

      checkVisibilityData
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/* global o_util AS */

/**
 * RUM extension to collect javascript errors.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM object.
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  /**
   * Function to handle and collect information about occuring javascript errors.
   *
   * @param {string|Object} message  Error message (or old browsers object).
   * @param {string} src      Source file.
   * @param {string} line     Line number the error occurs.
   * @param {string} column   Line number the error occurs.
   * @param {Object} error    The emitted error object.
   *
   * @return {Object} Data payload object.
   */
  function computeJsErrors(message, src, line, column, error) {
    const data = {
      jsErrors: -2,
      message: -2,
      src: -2,
      line: -2,
      column: -2,
      stack: -2
    };
    let key;

    if (RUM.localStorageAvailable) {
      key = `${AS.config.localStoragePrefix}jsErrors`;

      if (localStorage[key]) {
        localStorage[key] = parseInt(localStorage[key], 10) + 1;
      } else {
        localStorage[key] = 1;
      }

      data.jsErrors = localStorage[key] ? localStorage[key] : -1;
    } else {
      data.jsErrors = -1;
    }

    if (typeof message === "object") {
      try {
        message = JSON.stringify(message);
      } catch (e) {
        // TODO: implement error logging or custom event
      }
    }

    data.message = message || -1;
    data.src = src || -1;
    data.line = line || -1;
    data.column = column || -1;
    data.pagecluster = RUM.getPagecluster().pagecluster;
    data.stack = !!error && error.stack ? error.stack.substring(0, 512) : -1;

    return data;
  }

  // Add the javascript error detection to the RUM task queue.
  function _init() {
    if (o_util.toggle.get("RUM_JavascriptErrors", true)) {
      RUM.addToTaskQueue(
        "javascript",
        "error",
        "AS.RUM.computeJsErrors",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {

      computeJsErrors
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/* global o_util */

/**
 * RUM extension to detect page information.
 * Relies on a data-attribute on the html-node set by the backend.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM object
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  //  Add the page context features to the RUM task queue.
  function _init() {
    if (o_util.toggle.get("RUM_PageCluster", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getPagecluster",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/* global o_util */

/**
 * RUM extension to send custom requests.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM Object
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  /**
   * Public method to send a custom beacon.
   *
   * @param {string} namespace    Namespace to identify requests later on.
   * @param {Object} data         Payload object.
   *
   * @return {boolean} Return true in beacon was send, false otherwise.
   */
  function sendCustomRequest(namespace, data) {
    if (!o_util.toggle.get("RUM_CustomEvents", true)) {
      return false;
    }

    if (
      !!namespace &&
      typeof name === "string" &&
      namespace.length > 0 &&
      !!data &&
      typeof data === "object" &&
      Object.keys(data).length > 0
    ) {
      data.namespace = data.namespace ? data.namespace : namespace;
      data.timestamp = data.timestamp ? data.timestamp : new Date().getTime();
      data.pagecluster = RUM.getPagecluster().pagecluster;

      return RUM.sendImageBeacon("load", "custom", data, true);
    }

    return false;
  }

  return o_util.core.extend(
    RUM,
    {
      sendCustomRequest
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/**
 * RUM extension to detect screen dimensions and available screen dimensions.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM object.
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  /**
   * Retrieve information about screen width and height and also the available width and height.
   *
   * @return {Object} Data object holding dimension information.
   */
  function getScreenDimensions() {
    const data = {
      rum_width: -2,
      rum_height: -2,
      rum_clientWidth: -2,
      rum_clientHeight: -2
    };

    data.rum_width = w.screen.width ? w.screen.width : -1;
    data.rum_height = w.screen.height ? w.screen.height : -1;
    data.rum_clientWidth = d.documentElement.clientWidth
      ? d.documentElement.clientWidth
      : d.body.clientWidth
      ? d.body.clientWidth
      : -1;
    data.rum_clientHeight = d.documentElement.clientHeight
      ? d.documentElement.clientHeight
      : d.body.clientHeight
      ? d.body.clientHeight
      : -1;

    return data;
  }

  /**
   * Retrieve information about viewport innerWidth and innerHeight.
   *
   * @return {Object} Data object holding dimension information.
   */
  function getViewportDimensions() {
    const data = {
      rum_innerWidth: -2,
      rum_innerHeight: -2
    };

    data.rum_innerWidth = w.innerWidth ? w.innerWidth : -1;
    data.rum_innerHeight = w.innerHeight ? w.innerHeight : -1;

    return data;
  }

  /**
   * Returns the device pixel ratio.
   *
   * @return {Object} Retrieved device pixel ratio.
   */
  function getDevicePixelRatio() {
    const data = {
      rum_devicePixelRatio: -2
    };

    data.rum_devicePixelRatio = w.devicePixelRatio ? w.devicePixelRatio : -1;

    return data;
  }

  // Add the screen and device features to the RUM task queue.
  function _init() {
    if (o_util.toggle.get("RUM_ScreenSize", false)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getScreenDimensions",
        0,
        false
      );
    }

    if (o_util.toggle.get("RUM_Viewport", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getViewportDimensions",
        0,
        false
      );
    }

    if (o_util.toggle.get("RUM_DeviceInformation", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getDevicePixelRatio",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {

      getScreenDimensions,
      getDevicePixelRatio,
      getViewportDimensions
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/* global o_util o_global */

/**
 * RUM extension to retrieve device information based on string operations on the lowercased user agent.
 * Inspired by https://github.com/matthewhudson/device.js
 *
 * @param {Object} RUM      Global RUM object.
 * @param {Object} device   o_global.device object.
 */
window.AS.RUM = (function(RUM, device) {
  "use strict";

  /**
   * Fetch aggregated information about the visitor device which
   * consists of orientation, device type, operating system and browser.
   *
   * @return {Object} Payload data object.
   */
  function getDeviceData() {
    return {
      rum_deviceType: device.type,
      deviceOS: device.os,
      deviceBrowser: device.browser,
      rum_deviceOrientation: device.orientation.getCurrentOrientation(),
      rum_supportsTouch: device.isTouchable
    };
  }

  // Add the device data extraction to the RUM task queue.
  function _init() {
    if (o_util.toggle.get("RUM_DeviceInformation", true)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getDeviceData",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {

      getDeviceData
    },
    true,
    true
  );
})(window.AS.RUM || {}, o_global.device);


/**
 * RUM extension to detect screen dimensions and available screen dimensions.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM object.
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  /**
   * Check for the experimental navigator.connection.type feature.
   * Track the value if available.
   *
   * @see http://w3c.github.io/netinfo/#h-underlying-connection-technology
   *
   * @return {Object} ConnectionType.
   */
  function getConnectionType() {
    const data = {
      rum_connectionType: -2
    };
    let connection;

    if (typeof navigator !== "undefined") {
      connection =
        navigator.connection ||
        navigator.mozConnection ||
        navigator.webkitConnection;
      if (!!connection && typeof connection.type !== "undefined") {
        switch (parseInt(connection.type, 10)) {
          case 0:
            data.rum_connectionType = "unknown";
            break;
          case 1:
            data.rum_connectionType = "ethernet";
            break;
          case 2:
            data.rum_connectionType = "wifi";
            break;
          case 3:
            data.rum_connectionType = "cellular_2g";
            break;
          case 4:
            data.rum_connectionType = "cellular_3g";
            break;
          default:
            data.rum_connectionType = connection.type;
        }
      }
    }

    return data;
  }

  function getLoadingType() {
    return {
      loadingType: o_util.connection.getConnectionType()
    };
  }

  // Add the connectionfeatures to the RUM task queue.
  function _init() {
    if (o_util.toggle.get("RUM_Connection", false)) {
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getConnectionType",
        0,
        false
      );
      RUM.addToTaskQueue(
        "performance",
        "load",
        "AS.RUM.getLoadingType",
        0,
        false
      );
    }
  }

  _init();

  return o_util.core.extend(
    RUM,
    {
      getConnectionType,
      getLoadingType
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});


/* global o_tracking,o_util */

/**
 * RUM extension to interact with tracking and prepare data for usage in comScore.
 *
 * @param {Object} w        window
 * @param {Object} d        document
 * @param {Object} RUM      Global RUM Object.
 */
window.AS.RUM = (function(w, d, RUM) {
  "use strict";

  /**
   * Retrieve additional beacon parameter from tracking to merge tracking requests.
   *
   * @return {Object} Object based on tracking merge params.
   */
  function addMergeParameters() {
    let mergeParams = "";

    try {
      mergeParams = o_tracking.bct.getMergeParameters();
    } catch (e) {
      /* do nothing */
    }

    return typeof mergeParams === "string"
      ? o_util.core.deserialize(mergeParams.replace("?", ""), false)
      : {};
  }

  // Add the tracking features to the RUM task queue.
  function _init() {
    RUM.addToTaskQueue(
      "performance",
      "load",
      "AS.RUM.addMergeParameters",
      0,
      false
    );
  }

  _init();

  return o_util.core.extend(
    RUM,
    {
      addMergeParameters
    },
    true,
    true
  );
})(window, document, window.AS.RUM || {});
